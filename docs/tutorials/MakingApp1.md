# Разработка приложений для SynapseOs, Часть I: Установка утилит для разработки и HelloWorld
Здравствуйте! Если вы читаете этот гайд, то вы наверное хотите сделает своё приложение для нашей операционки? Тогда вы по адресу!
## Установка 
Установка утилит и всего и вся для SynapseOs проста:
Если ваша OS это ubuntu, введите в терминал следущию команду:
```sh
sudo apt-get install python3 clang llvm grub-pc-bin xorriso mtools lld git fasm libvirt-daemon libvirt-clients bridge-utils virt-manager qemu-kvm qemu virt-manager
```
Данная команда установит все средства для запуска(qemu) и компиляции операционной систему
Далее скачивает исходники операционной системы через git:
```sh
git clone https://github.com/0Nera/SynapseOS.git
```
Все преготовления закончены, теперь мы можем переходить к компиляции и запуску SynapseOs
## Компиляцияи и запуск
Для начала перейдите в папку с исходниками:
```
cd SynapseOs/
```
Так как SynapseOS использует для компиляции clang, вам бы пришлось вручную вводить все команды компиляции, но мы написали скрипт, который делает за вас компиляцию.
В папке с исходниками операционной системы введите команду:
```sh
python3 build.py
```
И он в автоматическом режиме всё соберёт и запустит в окне эмулятор, в котором будет наша операционка
## Теория разработки
И так, мы закончили установку, теперь переходим к теории работы.
Весь функционал операционной системы работает через мехназим 0x80 системных перываний
Для передачи данных системным прерываниям используються регистры
Регистры сисфункций:
 - eax - номер сисфункций
 - ebx - параметр 1
 - edx - параметр 2
 - ecx - параметр 3
 - esi - параметр 4
 - edi - параметр 5
 - ebp - параметр 6
В eax также идёт результат выполнения.
Вот пример использования системных функций с помощью ассемблера:
```asm
mov eax, 0; Задает прерывание 0(Вывод строки)
mov ebx, "HelloWorld"; Задает параметр 1(Его значение должно быть строкой)
int 80h ; Вызов прерывания
```
Данный код выведет HelloWorld в консоль
Также будет выглядить этот код на Си
```c
   # В stdio
   void print_str(char *str) {
     uint32_t result = 0;
     asm volatile("int $0x80" 
           : "=a"(result)         // result = eax (после выполнения)
           : "a"(SC_CODE_puts),   // eax = SC_CODE_puts(0)
             "b"(str)             // ebx = str
     );
     return result;
   }
   # В main.c
   <stdio.h>
   int main() {
     return print_str("Hello world!\\n");
   }
```
Как ни странно, он тоже выведет HelloWorld в консоль системы!
## Реальная разработка
Теперь, когда мы изучили теорию, можем начать практику
Для начала, перейди в папку apps, она находиться в папке с исходниками оськи
```sh
cd apps/
```
Теперь вы можете создать папку для нашего приложения. Я создам папку TestApp:
```sh
mkdir TestApp
```
Теперь можем начинать писать программу. Я решил написать её на fasm.
Назвал я файл test.asm, и кстати, называйте файл нормально, а это у вас не получиться его вызвать в SynapseOs
Вы можете написать программу на Си, но пока что я хочу просто показать, как это всё работает в коробке
```asm
; Hello World - FASM
format ELF
public main
main:
	mov eax, 0   ; 0 - сисфункция вывода принта
	mov ebx, "#ILOVESYNAPSEOS\n xd) " ; параметры сисфункции, в нашем случае строка для вывода
	int 80h ; Вызов прерывания
	mov eax, 20   ; 0 - сисфункция rand
	int 80h ; Вызов прерывания
	mov ebx, eax ; Перемещает вывод функции rand в первый аргумент сисфункции(для принта)
	mov eax, 0 ; 0- сисфункция принта
	int 80h ; Вызывает прерывание
	ret
```
Данный код, который я написал, сначала выводит #ILOVESYNAPSEOS\n xd) и потом выводит случайное число
Ну на этом, туториал завершён, удачи!
## Сисфункции
Также я оставил тут таблицу сисфункций
 - SC_CODE_puts            0
 - SC_CODE_getscancode     1
 - SC_CODE_getchar         2
 - SC_CODE_gets            3
 - SC_CODE_malloc          4
 - SC_CODE_free            5
 - SC_CODE_setdev          10
 - SC_CODE_readfile        11
 - SC_CODE_writefile       12
 - SC_CODE_exists          13
 - SC_CODE_filesize        14
 - SC_CODE_rand            20
 - SC_CODE_srand           21
 - SC_CODE_putpixel        32
 - SC_CODE_drawline        33
 - SC_CODE_version         40
 - SC_CODE_newtask         41
 - SC_CODE_ticks           42
